is_patient <- grepl("\\bPD(?:[ _-]?\\s*)?\\d+\\b", a, ignore.case = TRUE)
ifelse(is_patient, "patient", "control")
}
cellsius_res_new$subject_id = cellsius_res_new$group = NA
for (ii in 1:nrow(cellsius_res_new)) {
cellsius_res_new$subject_id[ii] = meta_data_all_use$patient[meta_data_all_use$barcode %in% cellsius_res_new$cell_id[ii]]
}
cellsius_res_new$group = patient_or_control(cellsius_res_new$subject_id)
View(meta_data_all_use)
cellsius_res_new$subject_id = cellsius_res_new$cell_type = NA
for (ii in 1:nrow(cellsius_res_new)) {
cellsius_res_new$subject_id[ii] = meta_data_all_use$patient[meta_data_all_use$barcode %in% cellsius_res_new$cell_id[ii]]
cellsius_res_new$cell_type[ii] = meta_data_all_use$cell_type[meta_data_all_use$barcode %in% cellsius_res_new$cell_id[ii]]
}
cellsius_res_new$group = patient_or_control(cellsius_res_new$subject_id)
colnames(rare_df) = c("cell_id", "subcluster", "subject_id", "group", "cell_type")
rare_df = cellsius_res_new
colnames(rare_df) = c("cell_id", "subcluster", "subject_id", "group", "cell_type")
View(rare_df)
## 1) 统计 n_{sk}
n_sk <- rare_df %>%
count(subject_id, group, subcluster, name = "n_sk")
library(dplyr)
library(tidyr)
## 1) 统计 n_{sk}
n_sk <- rare_df %>%
count(subject_id, group, subcluster, name = "n_sk")
View(n_sk)
## 2) 统计 N_s（总细胞数）
N_tbl <- meta_all %>%
count(subject_id, name = "N_s")
## 2) 统计 N_s（总细胞数）
N_tbl <- meta_data_all_use %>%
count(patient, name = "N_s")
View(N_tbl)
## 合并得到 y_{k,s} = n_{sk} / N_s；缺失填 0
y_long <- n_sk %>%
left_join(N_tbl, by = "subject_id") %>%
mutate(y = n_sk / N_s)
View(N_tbl)
## 合并得到 y_{k,s} = n_{sk} / N_s；缺失填 0
y_long <- n_sk %>%
left_join(N_tbl, by = "patient") %>%
mutate(y = n_sk / N_s)
View(n_sk)
rare_df = cellsius_res_new
colnames(rare_df) = c("cell_id", "subcluster", "patient", "group", "cell_type")
## 1) 统计 n_{sk}
n_sk <- rare_df %>%
count(subject_id, group, subcluster, name = "n_sk")
## 1) 统计 n_{sk}
n_sk <- rare_df %>%
count(patient, group, subcluster, name = "n_sk")
View(n_sk)
## 2) 统计 N_s（总细胞数）
N_tbl <- meta_data_all_use %>%
count(patient, name = "N_s")
## 合并得到 y_{k,s} = n_{sk} / N_s；缺失填 0
y_long <- n_sk %>%
left_join(N_tbl, by = "patient") %>%
mutate(y = n_sk / N_s)
View(y_long)
## 补上那些在该子簇没有 rare 细胞的受试者（y=0）
## 先罗列受试者 × 子簇的全组合
subjects <- N_tbl %>% left_join(rare_df %>% select(patient, group) %>% distinct(),
by = "patient")
View(subjects)
all_pairs <- expand_grid(patient = subjects$patient,
subcluster = unique(rare_df$subcluster)) %>%
left_join(subjects, by = "patient")  # 带上 group 和 N_s
View(all_pairs)
View(y_long)
y_long_full <- all_pairs %>%
left_join(y_long %>% select(patient, subcluster, y),
by = c("patient","subcluster")) %>%
mutate(y = ifelse(is.na(y), 0, y))
View(y_long_full)
View(y_long)
## 3) 整理成矩阵/向量以便检验
##   - Y: S × K 的受试者层面比例矩阵
##   - grp: 受试者组别因子
##   - Ns : 权重向量 N_s
Y <- y_long_full %>%
select(patient, subcluster, y) %>%
pivot_wider(names_from = subcluster, values_from = y, values_fill = 0) %>%
arrange(patient)
View(Y)
aa = rare_df[rare_df$subcluster == "4_2_1",]
View(aa)
aa = rare_df[rare_df$subcluster == "14_1_0",]
aa = rare_df[rare_df$subcluster == "13_1_0",]
grp_df <- subjects %>% arrange(patient)
View(grp_df)
#' @param nperm Integer. Number of label permutations. Default is \code{10000L}.
#' @param alternative Character. Type of alternative hypothesis:
#'   \code{"two.sided"} (default), \code{"greater"}, or \code{"less"}.
#' @param seed Integer. Random seed for reproducibility. Default is 42.
#' @return
#' \item{stat}{Observed test statistic \code{T}.}
#' \item{p.value}{Permutation p-value (according to \code{alternative}).}
#' \item{null}{Numeric vector of length \code{nperm}: permuted statistics \eqn{T^{(b)}}.}
#' \item{alternative}{The alternative hypothesis used.}
#' @export
perm_test_weighted <- function(y,                # numeric: subject-level posterior summary of pi_{dk}
g,                # factor/char: group labels, e.g., "patient"/"control"
w = NULL,         # numeric weights per subject; default 1
nperm = 10000L,   # permutations
alternative = c("two.sided","greater","less"),
seed = 42) {
stopifnot(length(y) == length(g))
if (is.null(w)) w <- rep(1, length(y))
alternative <- match.arg(alternative)
if (!is.null(seed)) set.seed(seed)
stat_fun <- function(y, g, w) {
g <- as.factor(g)
lev <- levels(g)
A <- g == lev[1]; B <- !A
wm <- function(x, ww) sum(ww * x) / sum(ww)
wm(y[A], w[A]) - wm(y[B], w[B])
}
T_obs <- stat_fun(y, g, w)
# permute group labels at subject level
T_perm <- numeric(nperm)
for (b in seq_len(nperm)) {
T_perm[b] <- stat_fun(y, sample(g), w)
}
# p-value
if (alternative == "two.sided") {
p <- (1 + sum(abs(T_perm) >= abs(T_obs))) / (nperm + 1)
} else if (alternative == "greater") {
p <- (1 + sum(T_perm >= T_obs)) / (nperm + 1)
} else {
p <- (1 + sum(T_perm <= T_obs)) / (nperm + 1)
}
list(stat = T_obs, p.value = p, null = T_perm, alternative = alternative)
}
stopifnot(identical(Y$patient, grp_df$patient))
Y_mat <- as.matrix(Y[ , -1, drop = FALSE])  # 去掉 patient 列
View(Y_mat)
View(Y)
grp   <- factor(grp_df$group)               # "PD"/"Ctrl"
grp
Ns    <- grp_df$N_s
Ns
## 4) 置换检验（使用你之前的 perm_test_weighted）
res_list <- lapply(unique(Y_long$subcluster), function(k){
dfk <- filter(Y_long, subcluster == k)
out <- perm_test_weighted(y = dfk$y, g = dfk$group, w = dfk$N_s, nperm = 20000L, seed = 1)
data.frame(subcluster = k, stat = out$stat, p_raw = out$p.value)
})
View(Y_mat)
View(y_long)
View(y_long_full)
unique(y_long$subcluster)
k="11_1_1"
dfk <- filter(y_long, subcluster == k)
View(dfk)
View(Y_mat)
length(unique(y_long$subcluster))
grp
kk=1
out <- perm_test_weighted(y = Y_mat[, kk], g = grp, w = Ns, nperm = 2e4, seed = 1)
## 4) 置换检验（使用你之前的 perm_test_weighted）
p_vec = numeric(length(unique(y_long$subcluster)))
for (kk in 1:length(unique(y_long$subcluster))) {
out <- perm_test_weighted(y = Y_mat[, kk], g = grp, w = Ns, nperm = 2e4, seed = 1)
p_vec[kk] = out$p.value
}
p_vec
unique(y_long$subcluster)[which(p_vec < 0.05)]
View(cellsius_res_new)
sig_clusters = which(p_vec < 0.05)
cellsius_res_new[cellsius_res_new$rare_subclusters == "4_2_1", ]
cellsius_res_new[cellsius_res_new$rare_subclusters == "6_2_1;6_1_1", ]
View(y_long_full)
group_summ <- y_long_full %>%
group_by(subcluster, group)
View(group_summ)
group_summ <- y_long_full %>%
group_by(subcluster, group) %>%
summarise(weighted_mean = wm(y, N_s), .groups = "drop")
wm <- function(x, w) sum(w*x)/sum(w)
group_summ <- y_long_full %>%
group_by(subcluster, group) %>%
summarise(weighted_mean = wm(y, N_s), .groups = "drop")
View(group_summ)
group_summ <- y_long_full %>%
group_by(subcluster, group) %>%
summarise(weighted_mean = wm(y, N_s), .groups = "drop") %>%
pivot_wider(names_from = group, values_from = weighted_mean,
names_prefix = "mean_")
View(group_summ)
res_df <- res_df %>%
left_join(group_summ, by = "subcluster") %>%
mutate(delta = mean_patient - mean_control)  # 若你的组名不同请对应修改
group_summ <- y_long_full %>%
group_by(subcluster, group) %>%
summarise(weighted_mean = wm(y, N_s), .groups = "drop")
View(group_summ)
group_summ <- y_long_full %>%
group_by(subcluster, group) %>%
summarise(weighted_mean = wm(y, N_s), .groups = "drop") %>%
pivot_wider(names_from = group, values_from = weighted_mean,
names_prefix = "mean_")
View(group_summ)
View(out)
out[["null"]]
cellsius_res_new[cellsius_res_new$rare_subclusters == "4_2_1", ]
cellsius_res_new[cellsius_res_new$rare_subclusters == "6_2_1;6_1_1", ]
# y: 长度 S 的受试者层面比例（某个 subcluster k 的 y_{s,k}）
# g: 长度 S 的组别因子，如 levels(g) = c("Ctrl","PD")
# w: 长度 S 的受试者权重（N_s）
# B: bootstrap 次数
boot_ci_two_group_weighted <- function(y, g, w, B = 20000, conf = 0.95, seed = 1) {
stopifnot(length(y)==length(g), length(w)==length(g))
set.seed(seed)
g <- droplevels(as.factor(g))
lev <- levels(g)                # 约定 lev[1]=对照, lev[2]=病例（按你factor顺序）
A <- which(g == lev[1]); Bidx <- which(g == lev[2])
wm <- function(x, ww) sum(ww * x) / sum(ww)
stat_once <- function(idxA, idxB) {
mA <- wm(y[idxA], w[idxA])
mB <- wm(y[idxB], w[idxB])
c(mean_A = mA, mean_B = mB, delta = mA - mB)
}
# 观测量
obs <- stat_once(A, Bidx)
# 受试者层面分组内有放回抽样
boot_mat <- matrix(NA_real_, nrow = 3, ncol = B)
for (b in seq_len(B)) {
AA <- sample(A, length(A), replace = TRUE)
BB <- sample(Bidx, length(Bidx), replace = TRUE)
boot_mat[, b] <- stat_once(AA, BB)
}
al <- (1 - conf)/2; au <- 1 - al
ci <- apply(boot_mat, 1, quantile, probs = c(al, 0.5, au), na.rm = TRUE)
# 返回观测点估计 + CI
list(
obs = obs,
ci = t(ci)  # 行: mean_A/mean_B/delta; 列:低/中/高
)
}
# sig_clusters 已按 p_vec < 0.05 得到
sub_levels <- colnames(Y_mat)  # 列名是 subcluster
keep <- sub_levels %in% unique(y_long$subcluster)[sig_clusters]
out_list <- vector("list", length = sum(keep))
names(out_list) <- sub_levels[keep]
out_list
colnames(Y_mat)
# sig_clusters 已按 p_vec < 0.05 得到
sub_levels <- colnames(Y_mat)  # 列名是 subcluster
keep <- sub_levels %in% unique(y_long$subcluster)[sig_clusters]
out_list <- vector("list", length = sum(keep))
names(out_list) <- sub_levels[keep]
for (nm in names(out_list)) {
k <- which(colnames(Y_mat) == nm)
out_list[[nm]] <- boot_ci_two_group_weighted(
y = Y_mat[, k], g = grp, w = Ns, B = 20000, seed = 123
)
}
# 汇总成表
res_ci <- do.call(rbind, lapply(names(out_list), function(nm){
oo <- out_list[[nm]]
data.frame(
subcluster = nm,
mean_ctrl = oo$obs["mean_A"],     # 若 lev[1] 是 Ctrl
mean_pd   = oo$obs["mean_B"],     # 若 lev[2] 是 PD
delta     = oo$obs["delta"],
ci_low_ctrl = oo$ci["mean_A", 1],
ci_med_ctrl = oo$ci["mean_A", 2],
ci_high_ctrl= oo$ci["mean_A", 3],
ci_low_pd   = oo$ci["mean_B", 1],
ci_med_pd   = oo$ci["mean_B", 2],
ci_high_pd  = oo$ci["mean_B", 3],
ci_low_delta= oo$ci["delta",  1],
ci_med_delta= oo$ci["delta",  2],
ci_high_delta=oo$ci["delta",  3]
)
}))
names(out_list)
nm = "4_2_1"
oo <- out_list[[nm]]
oo
nm = "6_2_1;6_1_1"
oo <- out_list[[nm]]
oo
cellsius_res_new[cellsius_res_new$rare_subclusters == "6_2_1;6_1_1", ]
NewFilePath = "/Users/yyq/Documents/MyDocuments/project/吴浩老师（深圳访问）/data/rare_cell/GSE157783/"
giniclust_res_new = read.csv(paste0(NewFilePath, "1_merged_GiniClust_rare_cells_with_clusters.csv"))
View(giniclust_res_new)
NewFilePath = "/Users/yyq/Documents/MyDocuments/project/吴浩老师（深圳访问）/data/rare_cell/GSE157783/"
giniclust_res_new = read.csv(paste0(NewFilePath, "1_merged_GiniClust_rare_cells_with_clusters.csv"))
patient_or_control <- function(a) {
# 匹配：PD + 可选分隔符(_/-/空格) + 至少一个数字
is_patient <- grepl("\\bPD(?:[ _-]?\\s*)?\\d+\\b", a, ignore.case = TRUE)
ifelse(is_patient, "patient", "control")
}
giniclust_res_new$subject_id = giniclust_res_new$cell_type = NA
for (ii in 1:nrow(giniclust_res_new)) {
giniclust_res_new$subject_id[ii] = meta_data_all_use$patient[meta_data_all_use$barcode %in% giniclust_res_new$cell_id[ii]]
giniclust_res_new$cell_type[ii] = meta_data_all_use$cell_type[meta_data_all_use$barcode %in% giniclust_res_new$cell_id[ii]]
}
giniclust_res_new$subject_id = giniclust_res_new$cell_type = NA
for (ii in 1:nrow(giniclust_res_new)) {
giniclust_res_new$subject_id[ii] = meta_data_all_use$patient[meta_data_all_use$barcode %in% giniclust_res_new$cell_name[ii]]
giniclust_res_new$cell_type[ii] = meta_data_all_use$cell_type[meta_data_all_use$barcode %in% giniclust_res_new$cell_name[ii]]
}
giniclust_res_new$group = patient_or_control(giniclust_res_new$subject_id)
View(giniclust_res_new)
rare_df = giniclust_res_new
View(rare_df)
giniclust_res_new = read.csv(paste0(NewFilePath, "1_merged_GiniClust_rare_cells_with_clusters.csv"))
patient_or_control <- function(a) {
# 匹配：PD + 可选分隔符(_/-/空格) + 至少一个数字
is_patient <- grepl("\\bPD(?:[ _-]?\\s*)?\\d+\\b", a, ignore.case = TRUE)
ifelse(is_patient, "patient", "control")
}
giniclust_res_new$subject_id = giniclust_res_new$cell_type = NA
for (ii in 1:nrow(giniclust_res_new)) {
giniclust_res_new$subject_id[ii] = meta_data_all_use$patient[meta_data_all_use$barcode %in% giniclust_res_new$cell_name[ii]]
giniclust_res_new$cell_type[ii] = meta_data_all_use$cell_type[meta_data_all_use$barcode %in% giniclust_res_new$cell_name[ii]]
}
giniclust_res_new$group = patient_or_control(giniclust_res_new$subject_id)
rare_df = giniclust_res_new
rare_df = giniclust_res_new
colnames(rare_df) = c("cell_id", "subcluster", "cell_type", "patient", "group")
## 1) 统计 n_{sk}
n_sk <- rare_df %>%
count(patient, group, subcluster, name = "n_sk")
## 2) 统计 N_s（总细胞数）
N_tbl <- meta_data_all_use %>%
count(patient, name = "N_s")
## 合并得到 y_{k,s} = n_{sk} / N_s；缺失填 0
y_long <- n_sk %>%
left_join(N_tbl, by = "patient") %>%
mutate(y = n_sk / N_s)
## 补上那些在该子簇没有 rare 细胞的受试者（y=0）
## 先罗列受试者 × 子簇的全组合
subjects <- N_tbl %>% left_join(rare_df %>% select(patient, group) %>% distinct(),
by = "patient")
all_pairs <- expand_grid(patient = subjects$patient,
subcluster = unique(rare_df$subcluster)) %>%
left_join(subjects, by = "patient")  # 带上 group 和 N_s
y_long_full <- all_pairs %>%
left_join(y_long %>% select(patient, subcluster, y),
by = c("patient","subcluster")) %>%
mutate(y = ifelse(is.na(y), 0, y))
## 3) 整理成矩阵/向量以便检验
##   - Y: S × K 的受试者层面比例矩阵
##   - grp: 受试者组别因子
##   - Ns : 权重向量 N_s
Y <- y_long_full %>%
select(patient, subcluster, y) %>%
pivot_wider(names_from = subcluster, values_from = y, values_fill = 0) %>%
arrange(patient)
grp_df <- subjects %>% arrange(patient)
stopifnot(identical(Y$patient, grp_df$patient))
Y_mat <- as.matrix(Y[ , -1, drop = FALSE])  # 去掉 patient 列
grp   <- factor(grp_df$group)               # "PD"/"Ctrl"
Ns    <- grp_df$N_s
## 4) 置换检验（使用你之前的 perm_test_weighted）
p_vec = numeric(length(unique(y_long$subcluster)))
for (kk in 1:length(unique(y_long$subcluster))) {
out <- perm_test_weighted(y = Y_mat[, kk], g = grp, w = Ns, nperm = 2e4, seed = 1)
p_vec[kk] = out$p.value
}
p_vec
unique(y_long$subcluster)[which(p_vec < 0.05)]
giniclust_res_new[giniclust_res_new$rare_subclusters == 9, ]
giniclust_res_new[giniclust_res_new$subclusters == 9, ]
giniclust_res_new$subclusters
giniclust_res_new[giniclust_res_new$cluster == 9, ]
giniclust_res_new[giniclust_res_new$cluster == 13, ]
sig_clusters = which(p_vec < 0.05)
# y: 长度 S 的受试者层面比例（某个 subcluster k 的 y_{s,k}）
# g: 长度 S 的组别因子，如 levels(g) = c("Ctrl","PD")
# w: 长度 S 的受试者权重（N_s）
# B: bootstrap 次数
boot_ci_two_group_weighted <- function(y, g, w, B = 20000, conf = 0.95, seed = 1) {
stopifnot(length(y)==length(g), length(w)==length(g))
set.seed(seed)
g <- droplevels(as.factor(g))
lev <- levels(g)                # 约定 lev[1]=对照, lev[2]=病例（按你factor顺序）
A <- which(g == lev[1]); Bidx <- which(g == lev[2])
wm <- function(x, ww) sum(ww * x) / sum(ww)
stat_once <- function(idxA, idxB) {
mA <- wm(y[idxA], w[idxA])
mB <- wm(y[idxB], w[idxB])
c(mean_A = mA, mean_B = mB, delta = mA - mB)
}
# 观测量
obs <- stat_once(A, Bidx)
# 受试者层面分组内有放回抽样
boot_mat <- matrix(NA_real_, nrow = 3, ncol = B)
for (b in seq_len(B)) {
AA <- sample(A, length(A), replace = TRUE)
BB <- sample(Bidx, length(Bidx), replace = TRUE)
boot_mat[, b] <- stat_once(AA, BB)
}
al <- (1 - conf)/2; au <- 1 - al
ci <- apply(boot_mat, 1, quantile, probs = c(al, 0.5, au), na.rm = TRUE)
# 返回观测点估计 + CI
list(
obs = obs,
ci = t(ci)  # 行: mean_A/mean_B/delta; 列:低/中/高
)
}
# sig_clusters 已按 p_vec < 0.05 得到
sub_levels <- colnames(Y_mat)  # 列名是 subcluster
keep <- sub_levels %in% unique(y_long$subcluster)[sig_clusters]
out_list <- vector("list", length = sum(keep))
names(out_list) <- sub_levels[keep]
for (nm in names(out_list)) {
k <- which(colnames(Y_mat) == nm)
out_list[[nm]] <- boot_ci_two_group_weighted(
y = Y_mat[, k], g = grp, w = Ns, B = 20000, seed = 123
)
}
# 汇总成表
nm = 9
oo <- out_list[[nm]]
sub_levels
keep <- sub_levels %in% unique(y_long$subcluster)[sig_clusters]
keep
# 汇总成表
nm = "9"
oo <- out_list[[nm]]
oo
nm = "13"
oo <- out_list[[nm]]
oo
g=grp
g
g <- droplevels(as.factor(g))
g
lev <- levels(g)
lev
A <- which(g == lev[1]); Bidx <- which(g == lev[2])
A
Bidx
AA <- sample(A, length(A), replace = TRUE)
AA
A
giniclust_res_new[giniclust_res_new$cluster == 9, ]
nrow(giniclust_res_new[giniclust_res_new$cluster == 9, ])
nrow(giniclust_res_new[giniclust_res_new$cluster == 13, ])
-2.455471e-04
3.957575e-05
unique(y_long$subcluster)
library(dplyr)
library(tidyr)
## 输入示例:
## rare_df: columns = subject_id, group, subcluster
## meta_all: 全部细胞（含非稀有），至少有 subject_id 一列
## 若没有 meta_all，则需自己提供 N_s（每个 subject 的总细胞数）
patient_or_control <- function(a) {
# 匹配：PD + 可选分隔符(_/-/空格) + 至少一个数字
is_patient <- grepl("\\bPD(?:[ _-]?\\s*)?\\d+\\b", a, ignore.case = TRUE)
ifelse(is_patient, "patient", "control")
}
cellsius_res_new$subject_id = cellsius_res_new$cell_type = NA
for (ii in 1:nrow(cellsius_res_new)) {
cellsius_res_new$subject_id[ii] = meta_data_all_use$patient[meta_data_all_use$barcode %in% cellsius_res_new$cell_id[ii]]
cellsius_res_new$cell_type[ii] = meta_data_all_use$cell_type[meta_data_all_use$barcode %in% cellsius_res_new$cell_id[ii]]
}
cellsius_res_new$group = patient_or_control(cellsius_res_new$subject_id)
cellsius_res_new[cellsius_res_new$rare_subclusters == "4_2_1", ]
cellsius_res_new[cellsius_res_new$rare_subclusters == "6_2_1;6_1_1", ]
rare_df = cellsius_res_new
colnames(rare_df) = c("cell_id", "subcluster", "patient", "group", "cell_type")
## 1) 统计 n_{sk}
n_sk <- rare_df %>%
count(patient, group, subcluster, name = "n_sk")
## 2) 统计 N_s（总细胞数）
N_tbl <- meta_data_all_use %>%
count(patient, name = "N_s")
## 合并得到 y_{k,s} = n_{sk} / N_s；缺失填 0
y_long <- n_sk %>%
left_join(N_tbl, by = "patient") %>%
mutate(y = n_sk / N_s)
## 补上那些在该子簇没有 rare 细胞的受试者（y=0）
## 先罗列受试者 × 子簇的全组合
subjects <- N_tbl %>% left_join(rare_df %>% select(patient, group) %>% distinct(),
by = "patient")
all_pairs <- expand_grid(patient = subjects$patient,
subcluster = unique(rare_df$subcluster)) %>%
left_join(subjects, by = "patient")  # 带上 group 和 N_s
y_long_full <- all_pairs %>%
left_join(y_long %>% select(patient, subcluster, y),
by = c("patient","subcluster")) %>%
mutate(y = ifelse(is.na(y), 0, y))
## 3) 整理成矩阵/向量以便检验
##   - Y: S × K 的受试者层面比例矩阵
##   - grp: 受试者组别因子
##   - Ns : 权重向量 N_s
Y <- y_long_full %>%
select(patient, subcluster, y) %>%
pivot_wider(names_from = subcluster, values_from = y, values_fill = 0) %>%
arrange(patient)
grp_df <- subjects %>% arrange(patient)
stopifnot(identical(Y$patient, grp_df$patient))
Y_mat <- as.matrix(Y[ , -1, drop = FALSE])  # 去掉 patient 列
grp   <- factor(grp_df$group)               # "PD"/"Ctrl"
Ns    <- grp_df$N_s
## 4) 置换检验（使用你之前的 perm_test_weighted）
p_vec = numeric(length(unique(y_long$subcluster)))
for (kk in 1:length(unique(y_long$subcluster))) {
out <- perm_test_weighted(y = Y_mat[, kk], g = grp, w = Ns, nperm = 2e4, seed = 1)
p_vec[kk] = out$p.value
}
p_vec
unique(y_long$subcluster)[which(p_vec < 0.05)]
