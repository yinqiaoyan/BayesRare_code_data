library(SingleCellExperiment)
library(scater)
library(umap)
## PCA
data_type = "ADTnorm"  # "rawcount" "CLR" "ADTnorm_arcsinh_transform" "ADTnorm"
Is_log1p = T
if (data_type == "rawcount") {
cat("rawcount\n")
print(Is_log1p)
if (Is_log1p) {
use_data = log1p(count_data_use)
} else {
use_data = count_data_use
}
} else if (data_type == "CLR") {
cat("CLR\n")
use_data = normalized_data
} else {
cat("ADTnorm\n")
use_data = cell_x_adt_norm3
}
dim(use_data)
### --- Zheng's codes --- ###
library(Seurat)
# set.seed(111)
n.PCs = ncol(use_data) - 2
# n.PCs = 20
protein_x_cell_matrix = t(use_data)
# subset_ids = sample(1:ncol(protein_x_cell_matrix), 5000)
subset_ids = 1:nrow(count_data_use)
dim(protein_x_cell_matrix)
protein_x_cell_matrix = protein_x_cell_matrix[, subset_ids]
dim(protein_x_cell_matrix)
### --- count data --- ###
s = CreateSeuratObject(count = protein_x_cell_matrix, data = protein_x_cell_matrix)
s = SetAssayData(s, assay = "RNA", slot = "scale.data", new.data = as.matrix(protein_x_cell_matrix)) ## by pass the Seurat normalization and scaling and set it to ADTnorm normalization results
s = FindVariableFeatures(s, selection.method = "vst", nfeatures = ncol(use_data))
s = RunPCA(s, npcs = n.PCs, verbose = FALSE)
s = RunUMAP(s, reduction = "pca", dims = 1:n.PCs, min_dist = 0.0001, n_neighbors = 20)  # , min_dist = 0.0001
pca_umap_res = s@reductions[["umap"]]@cell.embeddings
dim(pca_umap_res)
tmpcc = batch_info_filter
ppdata = data.frame(x = pca_umap_res[,1], y = pca_umap_res[,2], c = tmpcc)
# ppdata = ppdata[order(ppdata$c), ]
p = ggplot(data = ppdata, aes(x=x, y=y, c=c)) +
geom_point(aes(color=factor(c)), size = 0.01) +
guides(color = guide_legend(override.aes = list(size = 5))) #  +
# scale_color_manual(values=plot_color)
p
cell_types = c(as.character(triana@colData@listData[["cell_type_l1"]]),
as.character(hao@colData@listData[["celltype.l1"]]),
as.character(kotliarov@colData@listData[["cell_type_l1"]]),
as.character(witkowski@colData@listData[["cell_type_l1"]]),
scCUT_mydata_obj1$predicted.celltype.l1,
scCUT_mydata_obj2$predicted.celltype.l1,
scCUT_mydata_obj3$predicted.celltype.l1,
scCUT_mydata_obj4$predicted.celltype.l1,
scCUT_mydata_obj5$predicted.celltype.l1,
scCUT_mydata_obj6$predicted.celltype.l1)
cell_types = cell_types[cell_total_sum > 3 & cell_total_sum < 9]
length(cell_types)
length(batch_info_filter)
tmpcc = cell_types
ppdata = data.frame(x = pca_umap_res[,1], y = pca_umap_res[,2], c = tmpcc)
# ppdata = ppdata[order(ppdata$c), ]
p = ggplot(data = ppdata, aes(x=x, y=y, c=c)) +
geom_point(aes(color=factor(c)), size = 0.01) +
guides(color = guide_legend(override.aes = list(size = 5))) #  +
# scale_color_manual(values=plot_color)
p
### --- Zheng's codes --- ###
library(Seurat)
# set.seed(111)
# n.PCs = ncol(use_data) - 2
n.PCs = 20
protein_x_cell_matrix = t(use_data)
# subset_ids = sample(1:ncol(protein_x_cell_matrix), 5000)
subset_ids = 1:nrow(count_data_use)
dim(protein_x_cell_matrix)
protein_x_cell_matrix = protein_x_cell_matrix[, subset_ids]
dim(protein_x_cell_matrix)
### --- count data --- ###
s = CreateSeuratObject(count = protein_x_cell_matrix, data = protein_x_cell_matrix)
s = SetAssayData(s, assay = "RNA", slot = "scale.data", new.data = as.matrix(protein_x_cell_matrix)) ## by pass the Seurat normalization and scaling and set it to ADTnorm normalization results
s = FindVariableFeatures(s, selection.method = "vst", nfeatures = ncol(use_data))
s = RunPCA(s, npcs = n.PCs, verbose = FALSE)
s = RunUMAP(s, reduction = "pca", dims = 1:n.PCs, min_dist = 0.0001, n_neighbors = 20)  # , min_dist = 0.0001
pca_umap_res = s@reductions[["umap"]]@cell.embeddings
dim(pca_umap_res)
tmpcc = batch_info_filter
ppdata = data.frame(x = pca_umap_res[,1], y = pca_umap_res[,2], c = tmpcc)
# ppdata = ppdata[order(ppdata$c), ]
p = ggplot(data = ppdata, aes(x=x, y=y, c=c)) +
geom_point(aes(color=factor(c)), size = 0.01) +
guides(color = guide_legend(override.aes = list(size = 5))) #  +
# scale_color_manual(values=plot_color)
p
cell_types = c(as.character(triana@colData@listData[["cell_type_l1"]]),
as.character(hao@colData@listData[["celltype.l1"]]),
as.character(kotliarov@colData@listData[["cell_type_l1"]]),
as.character(witkowski@colData@listData[["cell_type_l1"]]),
scCUT_mydata_obj1$predicted.celltype.l1,
scCUT_mydata_obj2$predicted.celltype.l1,
scCUT_mydata_obj3$predicted.celltype.l1,
scCUT_mydata_obj4$predicted.celltype.l1,
scCUT_mydata_obj5$predicted.celltype.l1,
scCUT_mydata_obj6$predicted.celltype.l1)
cell_types = cell_types[cell_total_sum > 3 & cell_total_sum < 9]
length(cell_types)
length(batch_info_filter)
tmpcc = cell_types
ppdata = data.frame(x = pca_umap_res[,1], y = pca_umap_res[,2], c = tmpcc)
# ppdata = ppdata[order(ppdata$c), ]
p = ggplot(data = ppdata, aes(x=x, y=y, c=c)) +
geom_point(aes(color=factor(c)), size = 0.01) +
guides(color = guide_legend(override.aes = list(size = 5))) #  +
# scale_color_manual(values=plot_color)
p
dim(triana_use)
### --- Combine Data --- ###
combine_data = rbind(
triana_use,
# hao_use,
# kotliarov_use,
# witkowski_use,
scCUT_use_protein_count1_use,
scCUT_use_protein_count2_use,
scCUT_use_protein_count3_use,
scCUT_use_protein_count4_use,
scCUT_use_protein_count5_use,
scCUT_use_protein_count6_use
)
dim(combine_data)
count_data = combine_data
# count_data = combine_data
rownames(count_data) = paste0("V", 1:nrow(count_data))
uniq_triana = unique(triana@colData@listData[["batch"]])
batch_info_triana = c()
for (ii in 1:length(uniq_triana)) {
batch_info_triana = c(batch_info_triana, rep(uniq_triana[ii], sum(triana@colData@listData[["batch"]] == uniq_triana[ii])))
}
length(batch_info_triana)
batch_info = c(
batch_info_triana,
# batch_info_hao,
# batch_info_kotliarov,
# batch_info_witkowski,
rep("scCUT_H3K4me1", nrow(scCUT_use_protein_count1_use)),
rep("scCUT_H3K4me2", nrow(scCUT_use_protein_count2_use)),
rep("scCUT_H3K4me3", nrow(scCUT_use_protein_count3_use)),
rep("scCUT_H3K9me3", nrow(scCUT_use_protein_count4_use)),
rep("scCUT_H3K27ac", nrow(scCUT_use_protein_count5_use)),
rep("scCUT_H3K27me3", nrow(scCUT_use_protein_count6_use))
)
length(batch_info)
### --- Filter cells --- ###
# cell_total_sum = rowSums(count_data)
cell_total_sum = log1p(rowSums(count_data))
# cell_total_sum = rowSums(rawdf5_use)
data_vector = data.frame(sums = cell_total_sum)
pp = ggplot(data_vector, aes(x = sums)) +
geom_histogram(binwidth = 0.1, fill = "skyblue", color = "black") +
labs(title = "Histogram of data_vector", x = "Values", y = "Frequency") +
theme_minimal()
pp
mean(c(10,7.5))
##############################
## -- NO filter -- ##
count_data_filter = count_data
batch_info_filter = batch_info
cell_total_sum = log1p(rowSums(count_data_filter))
sort(cell_total_sum)[1:10]
count_data_filter = count_data_filter[cell_total_sum > 3 & cell_total_sum < 9, ]
batch_info_filter = batch_info_filter[cell_total_sum > 3 & cell_total_sum < 9]
length(batch_info_filter)
dim(count_data_filter)
length(batch_info_filter)
### data_use
count_data_use = count_data_filter
seurat_object <- CreateSeuratObject(counts = t(count_data_use))
seurat_object <- NormalizeData(seurat_object, normalization.method = "CLR", margin = 2)
normalized_data <- t(GetAssayData(seurat_object, slot = "data"))
colnames(normalized_data) = colnames(count_data_use)
dim(normalized_data)
# cell_x_feature = data.frame(sample = batch_info,
#                             batch = c(rep("fixed", nrow(count_data))))
cell_x_feature_use = data.frame(sample = paste0(batch_info_filter, "_sample"),
batch = paste0(batch_info_filter, "_batch"))
dim(cell_x_feature_use)
### --- ADTnorm --- ###
cell_x_adt = as.matrix(count_data_use)
dim(cell_x_adt)
save_outpath <- "/Users/yyq/Documents/MyDocument/project/郑晔 single-cell multiomics project/code/"
run_name <- "FilterZero_ADTnorm_demoRun_scCUT_and_triana_27pro_filterCell"
# cell_x_adt_norm3 <- ADTnorm(
#   cell_x_adt = cell_x_adt,
#   cell_x_feature = cell_x_feature,
#   save_outpath = save_outpath,
#   study_name = run_name,
#   # marker_to_process = common_elements[iii],
#   # trimodal_marker = c("CD4", "CD45RA"),
#   # positive_peak = list(ADT = "CD11c", sample = "scCUT_H3K4me1"),
#   save_fig = TRUE
# )
set.seed(12)
# cell_x_adt_norm3 <- ADTnorm(
#   cell_x_adt = cell_x_adt,
#   cell_x_feature = cell_x_feature,
#   save_outpath = save_outpath,
#   study_name = run_name,
#   # marker_to_process = common_elements[iii],
#   # trimodal_marker = c("CD4", "CD45RA"),
#   # positive_peak = list(ADT = "CD11c", sample = "scCUT_H3K4me1"),
#   save_fig = TRUE
# )
set.seed(12)
# use_ids = c(1, 3:25)
# use_ids = c(1:21,23:ncol(count_data_use))
use_ids = 1:ncol(count_data_use)
cell_x_adt_norm3 = matrix(NA, nrow=nrow(count_data_use), ncol=ncol(count_data_use))
for (iii in use_ids) {
cell_x_adt_norm_tmp <- ADTnorm(
cell_x_adt = cell_x_adt,
cell_x_feature = cell_x_feature_use,
save_outpath = save_outpath,
study_name = run_name,
marker_to_process = common_elements[iii],
# trimodal_marker = c("CD4", "CD45RA"),
# positive_peak = list(ADT = "CD11c", sample = "scCUT_H3K4me1"),
save_fig = TRUE
)
cell_x_adt_norm3[, iii] = as.matrix(cell_x_adt_norm_tmp)
}
# cell_x_adt_norm3 = cell_x_adt_norm3[, -c(22)]
colnames(cell_x_adt_norm3) = common_elements
dim(cell_x_adt_norm3)
### --- PCA + UMAP --- ###
library(SingleCellExperiment)
library(scater)
library(umap)
## PCA
data_type = "ADTnorm"  # "rawcount" "CLR" "ADTnorm_arcsinh_transform" "ADTnorm"
Is_log1p = T
if (data_type == "rawcount") {
cat("rawcount\n")
print(Is_log1p)
if (Is_log1p) {
use_data = log1p(count_data_use)
} else {
use_data = count_data_use
}
} else if (data_type == "CLR") {
cat("CLR\n")
use_data = normalized_data
} else {
cat("ADTnorm\n")
use_data = cell_x_adt_norm3
}
dim(use_data)
### --- Zheng's codes --- ###
library(Seurat)
# set.seed(111)
n.PCs = ncol(use_data) - 2
# n.PCs = 20
protein_x_cell_matrix = t(use_data)
# subset_ids = sample(1:ncol(protein_x_cell_matrix), 5000)
subset_ids = 1:nrow(count_data_use)
dim(protein_x_cell_matrix)
protein_x_cell_matrix = protein_x_cell_matrix[, subset_ids]
dim(protein_x_cell_matrix)
### --- count data --- ###
s = CreateSeuratObject(count = protein_x_cell_matrix, data = protein_x_cell_matrix)
s = SetAssayData(s, assay = "RNA", slot = "scale.data", new.data = as.matrix(protein_x_cell_matrix)) ## by pass the Seurat normalization and scaling and set it to ADTnorm normalization results
s = FindVariableFeatures(s, selection.method = "vst", nfeatures = ncol(use_data))
s = RunPCA(s, npcs = n.PCs, verbose = FALSE)
s = RunUMAP(s, reduction = "pca", dims = 1:n.PCs, min_dist = 0.0001, n_neighbors = 20)  # , min_dist = 0.0001
pca_umap_res = s@reductions[["umap"]]@cell.embeddings
dim(pca_umap_res)
tmpcc = batch_info_filter
ppdata = data.frame(x = pca_umap_res[,1], y = pca_umap_res[,2], c = tmpcc)
# ppdata = ppdata[order(ppdata$c), ]
p = ggplot(data = ppdata, aes(x=x, y=y, c=c)) +
geom_point(aes(color=factor(c)), size = 0.01) +
guides(color = guide_legend(override.aes = list(size = 5))) #  +
# scale_color_manual(values=plot_color)
p
### --- Combine Data --- ###
combine_data = rbind(
triana_use,
hao_use,
kotliarov_use,
witkowski_use,
scCUT_use_protein_count1_use,
scCUT_use_protein_count2_use,
scCUT_use_protein_count3_use,
scCUT_use_protein_count4_use,
scCUT_use_protein_count5_use,
scCUT_use_protein_count6_use
)
dim(combine_data)
count_data = combine_data
# count_data = combine_data
rownames(count_data) = paste0("V", 1:nrow(count_data))
uniq_triana = unique(triana@colData@listData[["batch"]])
batch_info_triana = c()
for (ii in 1:length(uniq_triana)) {
batch_info_triana = c(batch_info_triana, rep(uniq_triana[ii], sum(triana@colData@listData[["batch"]] == uniq_triana[ii])))
}
length(batch_info_triana)
uniq_hao = unique(hao@colData@listData[["batch"]])
batch_info_hao = c()
for (ii in 1:length(uniq_hao)) {
batch_info_hao = c(batch_info_hao, rep(uniq_hao[ii], sum(hao@colData@listData[["batch"]] == uniq_hao[ii])))
}
length(batch_info_hao)
uniq_kotliarov = unique(kotliarov@colData@listData[["batch"]])
batch_info_kotliarov = c()
for (ii in 1:length(uniq_kotliarov)) {
batch_info_kotliarov = c(batch_info_kotliarov, rep(uniq_kotliarov[ii], sum(kotliarov@colData@listData[["batch"]] == uniq_kotliarov[ii])))
}
length(batch_info_kotliarov)
uniq_witkowski = unique(witkowski@colData@listData[["batch"]])
batch_info_witkowski = c()
for (ii in 1:length(uniq_witkowski)) {
batch_info_witkowski = c(batch_info_witkowski, rep(uniq_witkowski[ii], sum(witkowski@colData@listData[["batch"]] == uniq_witkowski[ii])))
}
length(batch_info_witkowski)
batch_info = c(
batch_info_triana,
batch_info_hao,
batch_info_kotliarov,
batch_info_witkowski,
rep("scCUT_H3K4me1", nrow(scCUT_use_protein_count1_use)),
rep("scCUT_H3K4me2", nrow(scCUT_use_protein_count2_use)),
rep("scCUT_H3K4me3", nrow(scCUT_use_protein_count3_use)),
rep("scCUT_H3K9me3", nrow(scCUT_use_protein_count4_use)),
rep("scCUT_H3K27ac", nrow(scCUT_use_protein_count5_use)),
rep("scCUT_H3K27me3", nrow(scCUT_use_protein_count6_use))
)
length(batch_info)
##############################
## -- NO filter -- ##
count_data_filter = count_data
batch_info_filter = batch_info
cell_total_sum = log1p(rowSums(count_data_filter))
sort(cell_total_sum)[1:10]
count_data_filter = count_data_filter[cell_total_sum > 3 & cell_total_sum < 9, ]
batch_info_filter = batch_info_filter[cell_total_sum > 3 & cell_total_sum < 9]
length(batch_info_filter)
dim(count_data_filter)
length(batch_info_filter)
### data_use
count_data_use = count_data_filter
seurat_object <- CreateSeuratObject(counts = t(count_data_use))
seurat_object <- NormalizeData(seurat_object, normalization.method = "CLR", margin = 2)
normalized_data <- t(GetAssayData(seurat_object, slot = "data"))
colnames(normalized_data) = colnames(count_data_use)
dim(normalized_data)
### --- ADTnorm --- ###
cell_x_adt = as.matrix(count_data_use)
dim(cell_x_adt)
save_outpath <- "/Users/yyq/Documents/MyDocument/project/郑晔 single-cell multiomics project/code/"
run_name <- "FilterZero_ADTnorm_demoRun_scCUT_and_publicFour_filterCell2"
# cell_x_feature = data.frame(sample = batch_info,
#                             batch = c(rep("fixed", nrow(count_data))))
cell_x_feature_use = data.frame(sample = paste0(batch_info_filter, "_sample"),
batch = paste0(batch_info_filter, "_batch"))
dim(cell_x_feature_use)
### --- ADTnorm --- ###
cell_x_adt = as.matrix(count_data_use)
dim(cell_x_adt)
save_outpath <- "/Users/yyq/Documents/MyDocument/project/郑晔 single-cell multiomics project/code/"
run_name <- "FilterZero_ADTnorm_demoRun_scCUT_and_publicFour_filterCell2"
# cell_x_adt_norm3 <- ADTnorm(
#   cell_x_adt = cell_x_adt,
#   cell_x_feature = cell_x_feature,
#   save_outpath = save_outpath,
#   study_name = run_name,
#   # marker_to_process = common_elements[iii],
#   # trimodal_marker = c("CD4", "CD45RA"),
#   # positive_peak = list(ADT = "CD11c", sample = "scCUT_H3K4me1"),
#   save_fig = TRUE
# )
set.seed(12)
# use_ids = c(1, 3:25)
use_ids = c(1:21,23:ncol(count_data_use))
# use_ids = 1:ncol(count_data_use)
cell_x_adt_norm3 = matrix(NA, nrow=nrow(count_data_use), ncol=ncol(count_data_use))
for (iii in use_ids) {
cell_x_adt_norm_tmp <- ADTnorm(
cell_x_adt = cell_x_adt,
cell_x_feature = cell_x_feature_use,
save_outpath = save_outpath,
study_name = run_name,
marker_to_process = common_elements[iii],
# trimodal_marker = c("CD4", "CD45RA"),
# positive_peak = list(ADT = "CD11c", sample = "scCUT_H3K4me1"),
save_fig = TRUE
)
cell_x_adt_norm3[, iii] = as.matrix(cell_x_adt_norm_tmp)
}
cell_x_adt_norm3 = cell_x_adt_norm3[, -c(22)]
# colnames(cell_x_adt_norm3) = common_elements
dim(cell_x_adt_norm3)
### --- PCA + UMAP --- ###
library(SingleCellExperiment)
library(scater)
library(umap)
## PCA
data_type = "ADTnorm"  # "rawcount" "CLR" "ADTnorm_arcsinh_transform" "ADTnorm"
Is_log1p = T
if (data_type == "rawcount") {
cat("rawcount\n")
print(Is_log1p)
if (Is_log1p) {
use_data = log1p(count_data_use)
} else {
use_data = count_data_use
}
} else if (data_type == "CLR") {
cat("CLR\n")
use_data = normalized_data
} else {
cat("ADTnorm\n")
use_data = cell_x_adt_norm3
}
dim(use_data)
### --- Zheng's codes --- ###
library(Seurat)
# set.seed(111)
n.PCs = ncol(use_data) - 2
# n.PCs = 20
protein_x_cell_matrix = t(use_data)
# subset_ids = sample(1:ncol(protein_x_cell_matrix), 5000)
subset_ids = 1:nrow(count_data_use)
dim(protein_x_cell_matrix)
protein_x_cell_matrix = protein_x_cell_matrix[, subset_ids]
dim(protein_x_cell_matrix)
### --- count data --- ###
s = CreateSeuratObject(count = protein_x_cell_matrix, data = protein_x_cell_matrix)
s = SetAssayData(s, assay = "RNA", slot = "scale.data", new.data = as.matrix(protein_x_cell_matrix)) ## by pass the Seurat normalization and scaling and set it to ADTnorm normalization results
s = FindVariableFeatures(s, selection.method = "vst", nfeatures = ncol(use_data))
s = RunPCA(s, npcs = n.PCs, verbose = FALSE)
s = RunUMAP(s, reduction = "pca", dims = 1:n.PCs, min_dist = 0.0001, n_neighbors = 10)  # , min_dist = 0.0001
pca_umap_res = s@reductions[["umap"]]@cell.embeddings
dim(pca_umap_res)
tmpcc = batch_info_filter
ppdata = data.frame(x = pca_umap_res[,1], y = pca_umap_res[,2], c = tmpcc)
# ppdata = ppdata[order(ppdata$c), ]
p = ggplot(data = ppdata, aes(x=x, y=y, c=c)) +
geom_point(aes(color=factor(c)), size = 0.01) +
guides(color = guide_legend(override.aes = list(size = 5))) #  +
# scale_color_manual(values=plot_color)
p
### --- count data --- ###
s = CreateSeuratObject(count = protein_x_cell_matrix, data = protein_x_cell_matrix)
s = SetAssayData(s, assay = "RNA", slot = "scale.data", new.data = as.matrix(protein_x_cell_matrix)) ## by pass the Seurat normalization and scaling and set it to ADTnorm normalization results
s = FindVariableFeatures(s, selection.method = "vst", nfeatures = ncol(use_data))
s = RunPCA(s, npcs = n.PCs, verbose = FALSE)
s = RunUMAP(s, reduction = "pca", dims = 1:n.PCs, min_dist = 0.01, n_neighbors = 20)  # , min_dist = 0.0001
pca_umap_res = s@reductions[["umap"]]@cell.embeddings
dim(pca_umap_res)
### --- PCA + UMAP --- ###
library(SingleCellExperiment)
library(scater)
library(umap)
## PCA
data_type = "ADTnorm"  # "rawcount" "CLR" "ADTnorm_arcsinh_transform" "ADTnorm"
Is_log1p = T
if (data_type == "rawcount") {
cat("rawcount\n")
print(Is_log1p)
if (Is_log1p) {
use_data = log1p(count_data_use)
} else {
use_data = count_data_use
}
} else if (data_type == "CLR") {
cat("CLR\n")
use_data = normalized_data
} else {
cat("ADTnorm\n")
use_data = cell_x_adt_norm3
}
dim(use_data)
### --- Zheng's codes --- ###
library(Seurat)
# set.seed(111)
n.PCs = ncol(use_data) - 2
# n.PCs = 20
protein_x_cell_matrix = t(use_data)
# subset_ids = sample(1:ncol(protein_x_cell_matrix), 5000)
subset_ids = 1:nrow(count_data_use)
dim(protein_x_cell_matrix)
protein_x_cell_matrix = protein_x_cell_matrix[, subset_ids]
dim(protein_x_cell_matrix)
### --- count data --- ###
s = CreateSeuratObject(count = protein_x_cell_matrix, data = protein_x_cell_matrix)
s = SetAssayData(s, assay = "RNA", slot = "scale.data", new.data = as.matrix(protein_x_cell_matrix)) ## by pass the Seurat normalization and scaling and set it to ADTnorm normalization results
s = FindVariableFeatures(s, selection.method = "vst", nfeatures = ncol(use_data))
s = RunPCA(s, npcs = n.PCs, verbose = FALSE)
s = RunUMAP(s, reduction = "pca", dims = 1:n.PCs, min_dist = 0.01, n_neighbors = 20)  # , min_dist = 0.0001
pca_umap_res = s@reductions[["umap"]]@cell.embeddings
dim(pca_umap_res)
tmpcc = batch_info_filter
ppdata = data.frame(x = pca_umap_res[,1], y = pca_umap_res[,2], c = tmpcc)
# ppdata = ppdata[order(ppdata$c), ]
p = ggplot(data = ppdata, aes(x=x, y=y, c=c)) +
geom_point(aes(color=factor(c)), size = 0.01) +
guides(color = guide_legend(override.aes = list(size = 5))) #  +
# scale_color_manual(values=plot_color)
p
