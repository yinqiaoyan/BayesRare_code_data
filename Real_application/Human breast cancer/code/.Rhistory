}
# normalized_compact = normalized_vec(compact_vec)
normalized_sep = normalized_vec(sep_vec)
normalized_coverage = normalized_vec(coverage_vec)
# pk_vec <- logistic(w[1]*normalized_compact + w[2]*normalized_sep +
#                      w[3]*normalized_coverage + b)
pk_vec <- logistic(w[1]*normalized_sep + w[2]*normalized_coverage + b)
return(pk_vec)
}
normalized_vec = function(v) {
K_rare = length(v)
if (max(v) - min(v) == 0) {
return(rep(0.5, K_rare))
} else {
return((v - min(v)) / (max(v) - min(v)))
}
return(normalized_data)
}
gibbs_sampler_gamma <- function(X_list, K_rare, alpha, eta, tau_mu, nu1, nu0, tau_sigma,
centers_abundant,
w = c(1, 1), warm_start=FALSE,
n_iter = 100, burnIn = 50, random_seed = 42) {
set.seed(random_seed)
D <- length(X_list)                   # number of subjects
p <- ncol(X_list[[1]])                 # dimension
N_d <- sapply(X_list, nrow)            # cell number per subject
# Initialization
if (warm_start) {
X_all = do.call(rbind, X_list)  # total cell number * p_dim
kmeans_res = kmeans(X_all, centers=K_rare)
idx <- cumsum(N_d)
start_idx <- c(1, head(idx, -1) + 1)
end_idx <- idx
z <- mapply(function(s, e) kmeans_res$cluster[s:e], start_idx, end_idx, SIMPLIFY = FALSE)
pi_all <- prop.table(table(kmeans_res$cluster))
pi_d <- matrix(rep(pi_all, D), nrow = D, byrow = T)  # D*K_rare
mu_gk <- t(kmeans_res$centers)  # G*K_rare
sigmasq_gk <- matrix(NA, nrow = p, ncol = K_rare)  # G*K_rare
gamma_k <- rbinom(K_rare, 1, 0.5)
for (k in 1:K_rare) sigmasq_gk[, k] <- rinvgamma(p, ifelse(gamma_k[k] == 1, nu1, nu0), tau_sigma)
} else {
z <- lapply(1:D, function(d) sample(1:K_rare, N_d[d], replace = TRUE))
pi_d <- matrix(1/K_rare, nrow = D, ncol = K_rare)
mu_gk <- matrix(rnorm(p*K_rare, eta, tau_mu), nrow = p, ncol = K_rare)
sigmasq_gk <- matrix(NA, nrow = p, ncol = K_rare)
gamma_k <- rbinom(K_rare, 1, 0.5)
for (k in 1:K_rare) sigmasq_gk[, k] <- rinvgamma(p, ifelse(gamma_k[k] == 1, nu1, nu0), tau_sigma)
}
# Save results
samples <- list(z = list(), pi = list(), mu = list(), sigmasq = list(), gamma = list())
for (iter in 1:n_iter) {
### Update z and pi ###
for (d in 1:D) {
# -------- Update z --------
# cat("Update z\n")
X_d <- X_list[[d]]  # Nd*p_dim
Nd <- N_d[d]
tmp_mat <- matrix(0, nrow=Nd, ncol=K_rare)
for (k in 1:K_rare) {
tmp_mat[, k] = apply(X_d, 1, function(v){
sum(dnorm(v, mu_gk[, k], sqrt(sigmasq_gk[, k]), log = TRUE))
}) + log(pi_d[d,k])
}
tmp_mat <- tmp_mat - apply(tmp_mat, 1, max)
prob_mat <- exp(tmp_mat)
prob_mat <- prob_mat / rowSums(prob_mat)
z[[d]] <- apply(prob_mat, 1, function(pr) sample.int(K_rare, 1, prob=pr))
# -------- Update pi_d --------
# cat("Update pi_d\n")
n_k_vec_eachd <- tabulate(z[[d]], nbins = K_rare)  # labels must be 1,2,3,...,K_rare
pi_d[d,] <- as.numeric(rdirichlet(1, alpha + n_k_vec_eachd))
}
# for (d in 1:D) {
#   n_k_vec_eachd <- tabulate(z[[d]], nbins = K_rare)  # labels must be 1,2,3,...,K_rare
#   pi_d[d,] <- as.numeric(rdirichlet(1, alpha + n_k_vec_eachd))
# }
### Update gamma_k, mu_gk and sigmasq_gk ###
pk_vec = compute_gamma_prior(mu_gk, z, X_list, centers_abundant, w)
# n_k_vec <- tabulate(unlist(z), nbins = K_rare)
for (k in 1:K_rare) {
X_k <- do.call(rbind, lapply(1:D, function(d) {
idx <- which(z[[d]] == k)
if (length(idx) > 0) X_list[[d]][idx, , drop = FALSE]
}))
n_k <- nrow(X_k)
if (is.null(X_k)) {
gamma_k[k] = rbinom(1, 1, 0.5)
mu_gk[, k] <- rnorm(p, eta, tau_mu)
sigmasq_gk[, k] <- rinvgamma(p, ifelse(gamma_k[k] == 1, nu1, nu0), tau_sigma)
} else {
logRk = log(pk_vec[k]) - log(1 - pk_vec[k]) +
p * (
lgamma(nu1 + n_k / 2) - lgamma(nu0 + n_k / 2) - lgamma(nu1) + lgamma(nu0)
) + (nu1 - nu0) *
(p * log(tau_sigma) - sum(
log(tau_sigma + 0.5 * colSums((X_k - matrix(mu_gk[, k], nrow(X_k), ncol(X_k), byrow=T))^2))
))
p1 = 1 / (1 + exp(-logRk))
gamma_k[k] = rbinom(1, 1, p1)
# posterior var: ( n_k / sigma2_{gk} + 1/tau_mu^2 )^{-1}
post_var <- 1 / (n_k / sigmasq_gk[, k] + 1 / tau_mu^2)
post_mean <- post_var * ( colSums(X_k) / sigmasq_gk[, k] + eta / tau_mu^2 )
mu_gk[, k] <- rnorm(p, mean=post_mean, sd=sqrt(post_var))
post_shape <- ifelse(gamma_k[k] == 1, nu1, nu0) + n_k / 2
post_scale <- tau_sigma + 0.5 * colSums((X_k - matrix(mu_gk[, k], nrow(X_k), ncol(X_k), byrow=T))^2)
sigmasq_gk[,k] <- rinvgamma(p, shape=post_shape, scale=post_scale)
}
}
# Save results
if (iter > burnIn) {
samples$z[[iter - burnIn]] <- z
samples$pi[[iter - burnIn]] <- pi_d
samples$mu[[iter - burnIn]] <- mu_gk
samples$sigmasq[[iter - burnIn]] <- sigmasq_gk
samples$gamma[[iter - burnIn]] <- gamma_k
}
}
return(samples)
}
# ### Hyperparameters setting
# # K_rare
# # K=9
# D=length(X_list)
# alpha=1
# eta=0
# tau_mu=1
# nu1=2
# nu0=1
# tau_sigma=1
# warm_start=TRUE
# n_iter = 1000
# burnIn = 500
# random_seed = 22 # 2025
# # w = c(0.5, 0.5)  # make logistic function curve flatter than c(1,1)
# w = c(1, 1)
# # w = c(5, 5)
#
# # set.seed(42)
# ss.time = Sys.time()
# res <- gibbs_sampler_gamma(
#   X_list, K_rare, alpha, eta, tau_mu, nu1, nu0, tau_sigma,
#   centers_abundant,
#   w = w, warm_start=warm_start,
#   n_iter = n_iter, burnIn = burnIn, random_seed = random_seed
# )
# ee.time = Sys.time()
# ee.time - ss.time
## Run Gibbs
K_all = K_rare = 5
D=length(X_list)
alpha=1
eta=0
tau_mu=1
nu1=2
nu0=1
tau_sigma=1
warm_start=TRUE
n_iter = 1000
burnIn = 500
random_seed = 19 # 1  # resolution = 0.1
w = c(1, 1)
# set.seed(42)
ss.time = Sys.time()
res <- gibbs_sampler_gamma(
X_list, K_rare, alpha, eta, tau_mu, nu1, nu0, tau_sigma,
centers_abundant,
w = w, warm_start=warm_start,
n_iter = n_iter, burnIn = burnIn, random_seed = random_seed
)
ee.time = Sys.time()
ee.time - ss.time
getmode <- function(v) {
uniqv <- unique(v)
res <- uniqv[which.max(tabulate(match(v, uniqv)))]
return(res)
}
cat("===mcmc_iters: 501-1000===\n")
# mcmc_iters = 1:2
mcmc_iters = 1:500
gamma_mat = t(sapply(res$gamma[mcmc_iters], rbind))
z_res = vector("list", D)
for (d in 1:D) {
z_res[[d]] = apply(t(sapply(res$z[mcmc_iters], function(ll){ll[[d]]})), 2, getmode)
}
z_res
# gamma_res = apply(gamma_mat, 2, getmode)
# gamma_res
gamma_prop = apply(gamma_mat, 2, function(v){sum(v == 1) / nrow(gamma_mat)})
names(gamma_prop) = 1:length(gamma_prop)
gamma_prop
rare_candidates_post = which(gamma_prop > 0.5)
rare_candidates_post
umap_df_plot = as.data.frame(expr_pc_data)
tmpLabels = unlist(z_res)
tmpc2 = tmpLabels
tmpc2[tmpLabels == 1] = 5
tmpc2[tmpLabels == 2] = 4
tmpc2[tmpLabels == 3] = 3
tmpc2[tmpLabels == 4] = 1
tmpc2[tmpLabels == 5] = 2
tmpLabels = tmpc2
umap_df_plot$Group = paste0("C", tmpLabels)
plot_color <- c(
"#c63a32", "#3977af", "#f08536", "#4f9b6c", "#84584e",
"#d57fbe", "#b6bc6d", "#be9e96"
)
# p <- ggplot(umap_df_plot, aes(x = V1, y = V2, color = factor(Group))) +
#   geom_point(size = 2, alpha = 0.8) +
#   theme_minimal(base_size = 14) +
#   labs(title = "UMAP Projection", color = "Group") +
#   theme(
#     legend.position = "right",
#     plot.title = element_text(hjust = 0.5)
#   ) +
#   scale_color_manual(values=plot_color)
# p
p <- ggplot(umap_df_plot, aes(x = V1, y = V2, color = factor(Group))) +
geom_point(size = 1.5, alpha = 0.8) +
theme_minimal(base_size = 14) +
scale_color_manual(values = plot_color) +
theme_classic(base_size = 37) +
labs(
x = "Dimension 1",
y = "Dimension 2"
) +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5),
panel.background = element_blank(),
plot.background  = element_blank(),
legend.text      = element_text(size = 25),
legend.key.size  = unit(2.5, "line")
) +
# 图例点大小统一并适当放大
guides(color = guide_legend(title = NULL, override.aes = list(size = 7))) +
coord_cartesian(xlim = c(-11, 15), ylim = c(-5, 15))
p
# ggsave(paste0(ImageSavePath,"figure2c.png"), p, width = 11, height = 9, dpi = 100)
## wilcox.test using posterior mean of pi
mean_mat <- Reduce(`+`, res$pi) / length(res$pi)
View(mean_mat)
rare_candidates_post
remove.packages("BayesRare")
install.packages("/Users/yyq/Documents/MyDocuments/project/吴浩老师（深圳访问）/code/Rpkg/BayesRare1.0/BayesRare_1.0.tar.gz", repos = NULL, type="source")
library(BayesRare)
### --- new sim: cancer vs normal patients --- ###
library(mvtnorm)
library(ggplot2)
# library(MCMCpack)   # for rdirichlet, riwish
rm(list = ls())
## Data generation
set.seed(123)
# 前3类是rare(false positive)，中间2类是new cell types(true positive)
# 后3类是 abundant clusters(true negative)
# true 1 集中在cancer patients中, 2 无显著差异
n_mat = matrix(NA, nrow=8, ncol=8)
# normal
n_mat[1, ]  = c(80, 80, 80,  0, 15, 1000, 1500, 2000)
n_mat[2, ]  = c(80,  0, 79,  0,  0, 1000, 1500, 2000)
n_mat[3, ]  = c(80, 81, 79,  0, 15, 1000, 1500, 2000)
n_mat[4, ]  = c( 0, 79, 80,  0,  0, 1000, 1500, 2000)
# cancer
n_mat[5, ]  = c(81, 79,  0, 15,  0, 1000, 1500, 2000)
n_mat[6, ]  = c(81, 79,  0, 15, 15, 1000, 1500, 2000)
n_mat[7, ]  = c(81,  0, 80, 15,  0, 1000, 1500, 2000)
n_mat[8, ]  = c( 0, 79, 80, 15, 15, 1000, 1500, 2000)
#                  1    2    3    4    5    6    7    8
true_mean1   = c( 10,   2,   1,  -3, -10,  10,   0,  12)
true_mean2   = c( 10,   7,   3,  -4,  -3,   0,   9,   9)
true_sigmasq = c(1.2, 1.2, 1.2, 0.1, 0.1, 1.5, 1.5, 1.5)
num_patients = 4
sum(n_mat)
sum(n_mat[, 1:5])
15 * 8 / sum(n_mat)
D = nrow(n_mat)
K = length(true_mean1)
p_dim = 2
true_labels_list = vector("list", D)
for (d in 1:D) {
true_labels_list[[d]] = rep(1:length(n_mat[d,]), n_mat[d,])
}
K_each_mat = n_mat
K_each_mat[n_mat > 0] = 1
X_list <- X_all_list <- vector("list", D)
expr_pc_data_nonrare = NULL
for (d in 1:D) {
for (ii in which(K_each_mat[d,] > 0)) {
tmpmat = rmvnorm(n_mat[d, ][ii], mean = c(true_mean1[ii], true_mean2[ii]), sigma = diag(rep(true_sigmasq[ii], p_dim)))
if (ii <= 5) {
X_list[[d]] = rbind(X_list[[d]], tmpmat)
}
if (ii > 5) {
expr_pc_data_nonrare = rbind(expr_pc_data_nonrare, tmpmat)
}
X_all_list[[d]] = rbind(X_all_list[[d]], tmpmat)
}
}
expr_pc_data = do.call(rbind, X_list)
# ## abundant clusters
# centers_abundant = cbind(true_mean1[(K - 2):K], true_mean2[(K - 2):K])
# ## plot
# plot_all = function() {
#   df_all = data.frame(rbind(do.call(rbind, X_all_list)))
#   colnames(df_all) <- c("X1", "X2")
#
#   pp=ggplot(df_all, aes(x = X1, y = X2)) +
#     geom_point(alpha=0.6) +
#     labs(title = "Combine all",
#          x = "Feature 1",
#          y = "Feature 2")+
#     theme(
#       plot.title = element_text(size = 30, face = "bold")
#     )
#   # pp
#   return(pp)
# }
# pp = plot_all()
# pp
# cell_type_labels = NULL
# for (d in 1:8) {
#   cell_type_labels = c(cell_type_labels, rep(1:8, n_mat[d, ]))
# }
# df_all = data.frame(rbind(do.call(rbind, X_all_list)))
# colnames(df_all) <- c("X1", "X2")
# df_all$true_type = cell_type_labels
#
# plot_color=c("#3977af", "#c2b2d2", "#f08536", "#4f9b6c", "#84584e", "#d57fbe", "#b6bc6d", "#be9e96",
#              "#c63a32", "#f29d99", "#54b0c2", "#9d51f3", "#b2c7e5", "#a8dc93", "#f6bd82", "#A3A500", "#00BF7D")
# pp=ggplot(df_all, aes(x = X1, y = X2, color = factor(true_type))) +
#   geom_point(alpha=0.5) +
#   labs(title = "Combine all",
#        x = "Feature 1",
#        y = "Feature 2")+
#   theme(
#     plot.title = element_text(size = 30, face = "bold")
#   ) +
#   scale_color_manual(values=plot_color)
# pp
ImageSavePath = "/Users/yyq/Documents/MyDocuments/project/吴浩老师（深圳访问）/figs/manuscript/"
cell_type_labels = NULL
for (d in 1:8) {
cell_type_labels = c(cell_type_labels, rep(paste0("A", 1:8), n_mat[d, ]))
}
df_all = data.frame(rbind(do.call(rbind, X_all_list)))
colnames(df_all) <- c("X1", "X2")
df_all$true_type = cell_type_labels
plot_color <- c(
"A1" = "#c63a32",
"A2" = "#3977af",
"A3" = "#f08536",
"A4" = "#4f9b6c",
"A5" = "#84584e",
"A6" = "#f7d8ed", #"#d57fbe",
"A7" = "#E9EBD0", #"#b6bc6d",
"A8" = "#EEE2E0"  #"#be9e96"
)
p <- ggplot(df_all, aes(x = X1, y = X2, color = factor(true_type))) +
geom_point(
data = subset(df_all, true_type %in% c("A6","A7","A8")),
aes(color = factor(true_type)),
size = 0.5, alpha = 0.8
) +
geom_point(
data = subset(df_all, true_type %in% c("A1","A2","A3")),
aes(color = factor(true_type)),
size = 1.5, alpha = 0.8
) +
geom_point(
data = subset(df_all, true_type %in% c("A4","A5")),
aes(color = factor(true_type)),
size = 1.5, alpha = 0.8
) +
# geom_point(size = 0.5, alpha = 0.8) +
theme_classic(base_size = 37) +
labs(
x = "Dimension 1",
y = "Dimension 2"
) +
scale_color_manual(
name   = NULL,
breaks = paste0("A", 1:8),  # 图例顺序
values = plot_color
) +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5),
panel.background = element_blank(),
plot.background  = element_blank(),
legend.text      = element_text(size = 25),
legend.key.size  = unit(2.5, "line")
) +
# 图例点大小统一并适当放大
guides(color = guide_legend(title = NULL, override.aes = list(size = 7))) +
coord_cartesian(xlim = c(-11, 15), ylim = c(-5, 15))
p
# ggsave(paste0(ImageSavePath,"figure2a.png"), p, width = 11, height = 9, dpi = 100)
##################
##   pipeline   ##
##################
library(Seurat)
# library(dplyr)
# library(Matrix)
pca_mat <- expr_pc_data_nonrare
pca_mat <- as.matrix(pca_mat)
ncells <- nrow(pca_mat)
npc    <- ncol(pca_mat)
rownames(pca_mat) <- paste0("Cell_", seq_len(ncells))
colnames(pca_mat) <- paste0("PC_", seq_len(npc))
## ---- 1) 构造“占位”counts（1个基因 × N个细胞），且是 dgCMatrix，且无下划线 ----
# 特别注意：feature 名不能有下划线
feature_name <- "fakegene"  # 不要用 fake_gene
placeholder_counts <- matrix(0, nrow=npc, ncol=ncells)
# # 确保是 dgCMatrix（有时 Matrix(0, ...) 已是，保险起见可再强转）
# placeholder_counts <- as(placeholder_counts, "dgCMatrix")
# 双重检查：二维 & 维度名
# stopifnot(length(dim(placeholder_counts)) == 2)
# stopifnot(!is.null(rownames(placeholder_counts)), !is.null(colnames(placeholder_counts)))
## ---- 2) 创建 Seurat 对象 ----
obj <- CreateSeuratObject(counts = placeholder_counts, project = "FromPCA")
DefaultAssay(obj) <- "RNA"
## ---- 2) 把 PCA 嵌入加为 DimReduc ----------------------------------------
# embeddings 要求：行=细胞、列=维度
pca_dr <- CreateDimReducObject(
embeddings = pca_mat,
key = "PC_",
assay = DefaultAssay(obj)
)
obj[["pca"]] <- pca_dr
## ---- 3) 直接基于 pca 做邻居图、聚类、UMAP -------------------------------
# 选择使用多少个 PC
use_dims <- 1:npc
set.seed(42)
obj <- FindNeighbors(obj, reduction = "pca", dims = use_dims)
# obj <- FindClusters(obj, resolution = 0.01)  # resolution 0.01: true 3 classes
obj <- FindClusters(obj, resolution = 0.1)
umap_df_plot = as.data.frame(pca_mat)
umap_df_plot$Group = obj@meta.data[["seurat_clusters"]]
plot_color=c("#3977af", "#c2b2d2", "#f08536", "#4f9b6c", "#84584e", "#d57fbe", "#b6bc6d", "#be9e96",
"#c63a32", "#f29d99", "#54b0c2", "#9d51f3", "#b2c7e5", "#a8dc93", "#f6bd82", "#A3A500", "#00BF7D")
p <- ggplot(umap_df_plot, aes(x = PC_1, y = PC_2, color = factor(Group))) +
geom_point(size = 2, alpha = 0.8) +
theme_minimal(base_size = 14) +
labs(title = "UMAP Projection", color = "Group") +
theme(
legend.position = "right",
plot.title = element_text(hjust = 0.5)
) +
scale_color_manual(values=plot_color)
p
mu_gk_fixed = NULL
sigmasq_gk_fixed = NULL
n_k_abundant = NULL
res_seurat = as.numeric(obj@meta.data[["seurat_clusters"]])
uniq_seurat = sort(unique(res_seurat))
for (k_abund in seq_len(length(uniq_seurat))) {
tmp_ids = which(res_seurat == uniq_seurat[k_abund])
tmp_expr = expr_pc_data_nonrare[tmp_ids, ]
mu_gk_fixed = cbind(mu_gk_fixed, colMeans(tmp_expr))
sigmasq_gk_fixed = cbind(sigmasq_gk_fixed, apply(tmp_expr, 2, var))
n_k_abundant = c(n_k_abundant, length(tmp_ids))
}
## abundant clusters
# centers_abundant = cbind(true_mean1[(K - 2):K], true_mean2[(K - 2):K])
centers_abundant = t(mu_gk_fixed)  # Kp x G
res = BayesRare_train(X_list=X_list,
K_init=5,
mu_gk_fixed=mu_gk_fixed,
sigmasq_gk_fixed=sigmasq_gk_fixed,
patient_group_ids=5:8, control_group_ids=1:4,
random_seed=19,
do_test=TRUE,
verbose_time=TRUE, verbose_em=TRUE)
res
rm(list = ls())
library(BayesRare)
library(ggplot2)
## Set the working directory to the source file location
current_dir <- dirname(rstudioapi::getSourceEditorContext()$path)
setwd(current_dir)
print(getwd())
## Read in data
expr_pc = read.csv("../input_data/X_pca_py.csv")  # python preprocessing code
meta_data_all = read.csv("../input_data/raw_metadata.csv")
clust_res_all = read.csv("../input_data/scCAD_detection_results.tsv", sep = "\t")
colnames(meta_data_all)[colnames(meta_data_all) == "Patient"]    <- "donor_id"
colnames(meta_data_all)[colnames(meta_data_all) == "SubCluster"] <- "cell_type"
rare_candidates_id = which(clust_res_all$rare_subcluster_id != -1)
out_proc = data_preprocess(expr_pc, meta_data_all, clust_res_all)
true_rare_types = c("pDC", "Mast")
total_labels = meta_data_all$cell_type[res_BayesRare$rare_ids]
View(meta_data_all)
out_proc = data_preprocess(expr_pc, meta_data_all, clust_res_all)
View(clust_res_all)
meta_data = meta_data_all
initial_clust_res =clust_res_all
expr_pc_data = expr_pc[, -1] # cells x nPCs
dim(expr_pc_data)
sum(is.na(expr_pc_data))
K_init = length(unique(initial_clust_res$rare_subcluster_id)) - 1
rare_candidates_id = which(initial_clust_res$rare_subcluster_id != -1)
nonrare_candidates_id = which(initial_clust_res$rare_subcluster_id == -1)
expr_pc_data_cand = expr_pc_data[rare_candidates_id, ]
expr_pc_data_nonrare = expr_pc_data[nonrare_candidates_id, ]
patients_id = meta_data$donor_id[rare_candidates_id]
## X_list data
rownames(expr_pc_data_cand) <- rare_candidates_id
X_list <- split.data.frame(expr_pc_data_cand, patients_id)
cat("## Conduct Seurat...\n")
pca_mat <- as.matrix(expr_pc_data_nonrare)
ncells <- nrow(pca_mat)
npc    <- ncol(pca_mat)
rownames(pca_mat) <- paste0("Cell_", seq_len(ncells))
